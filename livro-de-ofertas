#include <iostream>
using namespace std;

class Book {
  public:
	double value;
	int quantity;
	
	void setValue(double v){
		value = v;
	}
	void setQuantity(int q){
		quantity = q;
	}
	
	Book(double v, int q){
		value = v;
		quantity = q;
	}
	
	friend std::ostream& operator<<(std::ostream& os, const Book& data) {
        os << data.value << ",";
        os << data.quantity;
        return os;
    }
};

class Node {
  public:
    int position;
	Book data;
	Node *next;
	
	Node(const Book& properties, int p) : data(properties), next(nullptr) {
	  position = p;
   }
		};

void printList(Node*n) {
	while (n != NULL) {
		cout << n->position << "," << n->data << endl;
		
		n = n->next;
	}
}

void insertAtHead(Node**head,int position, Book newBook) {
	Node* newNode = new Node(newBook, position);
	newNode->position =1;
	newNode->data = newBook;
	newNode->next = *head;
	*head = newNode;
}

void insertAt(Node**head, int position, Book newBook) {
	Node* newNode = new Node(newBook, position);
	newNode->data = newBook;
	
	Node* last = *head;
	Node* previous;
	
	while( last->next != NULL && last->position < position){
		previous = last;
		last = last->next;
	}
	if(last->position == position){
		newNode->position = last->position;
		newNode->next = last->next;
		previous->next = newNode;
	} else {
				newNode->position = last->position + 1;
				newNode->next = last->next;
				last->next = newNode;	
	}
}

Node* search(Node* head, int position) {
    Node* currentNode = head;
    while (currentNode != nullptr) {
        if (currentNode->position == position) {
            return currentNode;
        }
        currentNode = currentNode->next;
    }
    return nullptr;
}

void deleteNode(Node* &head, Node* previous, Node* toRemove){
	if(toRemove == head){
		head = toRemove->next;
		delete toRemove;
	} else if(toRemove){
	previous->next = toRemove->next;
	delete toRemove;
	}
}

int main(int argc, char *argv[])
{
	Node* head = NULL;
	Node* temp = NULL;
	int notifications = 0;
	int books = 0;

	while (notifications <= 0)
	{
		cout << "How many notifications? ";
		cin >> notifications;
		if (notifications <= 0)
		{
			cout << "Wrong value, please type a number greater than zero.";
		}
	}
	
	int position = 0;
	int action;
	double value = 0.0;
	int quantity = 0;

	while (notifications > 0)
	{
		while (position <= 0)
		{
			cout << "Position: ";
			cin >> position;

			if (position <= 0)
			{
				cout << "Wrong value, type a integer greater than zero \n";
			}
		}

		while (action < 0 || action > 2)
		{
			cout << "Action: ";
			cin >> action;

			if (action < 0 || action > 2)
			{
				cout << "Please choose between 0, 1, or 2 \n";
			}
		}
		
		switch (action)
		{
		case 0:
		while ( value <= 0) {
			cout << "Value: ";
			cin >> value;
			
			if (value <= 0)
			{
				cout << "Wrong value, type a number greater than zero \n";
			}
		}
		
		while ( quantity <= 0) {
			cout << "Quantity: ";
			cin >> quantity;
			
			if (quantity <= 0)
			{
				cout << "Wrong value, type a number greater than zero \n";
			}
		}
		
			if( head == NULL || position == 1) {
				Book newBook(value, quantity);
				insertAtHead(&head, position, newBook);
			} else {
				Book newBook(value, quantity);
				insertAt(&head, position, newBook);
			}
			break;
		case 1:
		
	    temp = search(head, position);
   
        if(!temp) {
            cout << "Don't have any element in this position!" << endl;
        } else{
            while ( value < 0) {
        		cout << "Value: ";
			    cin >> value;
            }
            if (value < 0)
			{
				cout << "Don't allowed negative numbers" << endl;
			} else if ( value != 0) {
				temp->data.setValue(value);
			}
      }
      while ( quantity < 0) {
			cout << "Quantity: ";
			cin >> quantity;
			
            if (quantity < 0)
			{
				cout << "Don't allowed negative numbers" << endl;
			} else if ( quantity != 0) {
				temp->data.setQuantity(quantity);
			}
      }   
			break;
		case 2:
		if(head){
			temp = search(head, position);
			Node* previous = search(head, position -1);
			
			deleteNode(head, previous, temp);
		}
			break;
		}

		notifications--;
		position = 0;
		value = -1.0;
		quantity = -1;
		action = -1;
	}
	
	printList(head);

}
